
 use crate::vxeddsa::{VXEdDSAOutput, vxeddsa_sign, vxeddsa_verify};
 use aes_gcm::{
     Aes256Gcm, Key, Nonce,
     aead::{Aead, KeyInit, Payload},
 };
 use hkdf::Hkdf;
 use hmac::{Hmac, Mac};
 use sha2::{Sha256, Sha512};
 use std::collections::HashMap;
 use x25519_dalek::{PublicKey, StaticSecret};
 use zeroize::{Zeroize, ZeroizeOnDrop};

 /// Error types for Ratchet operations
 #[derive(Debug, PartialEq)]
 pub enum RatchetError {
     InvalidSignature,
     InvalidKey,
     DecryptionFailed,
     OldMessageKeysLimitReached,
     DuplicateMessage,
     InvalidHeader,
 }

 // ----------------------------------------------------------------------------
 // Constants and Configuration
 // ----------------------------------------------------------------------------

 const MAX_SKIP: u32 = 1000;
 const HKDF_INFO_ROOT: &[u8] = b"Signal-DoubleRatchet-Root";

 // ----------------------------------------------------------------------------
 // Types
 // ----------------------------------------------------------------------------

 pub type DhPublicKey = PublicKey;
 pub type DhPrivateKey = StaticSecret;
 pub type KeyPair = (DhPrivateKey, DhPublicKey);

 /// The Header sent with every message
 #[derive(Clone, Debug, PartialEq)]
 pub struct RatchetHeader {
     pub dh_pub: DhPublicKey,
     pub pn: u32,
     pub n: u32,
     pub signature: [u8; 96], // VXEdDSA Signature
 }

 impl RatchetHeader {
     /// Serializes the header components that need to be signed.
     /// Format: [dh_pub (32)] || [pn (4, be)] || [n (4, be)]
     pub fn to_bytes_for_signing(&self) -> Vec<u8> {
         let mut bytes = Vec::with_capacity(32 + 4 + 4);
         bytes.extend_from_slice(self.dh_pub.as_bytes());
         bytes.extend_from_slice(&self.pn.to_be_bytes());
         bytes.extend_from_slice(&self.n.to_be_bytes());
         bytes
     }

     /// Serializes the full header to a byte vector.
     /// Format: [dh_pub (32)] || [pn (4, be)] || [n (4, be)] || [signature (96)]
     pub fn to_bytes(&self) -> Vec<u8> {
         let mut bytes = Vec::with_capacity(32 + 4 + 4 + 96);
         bytes.extend_from_slice(self.dh_pub.as_bytes());
         bytes.extend_from_slice(&self.pn.to_be_bytes());
         bytes.extend_from_slice(&self.n.to_be_bytes());
         bytes.extend_from_slice(&self.signature);
         bytes
     }

     /// Deserializes the header from a byte slice.
     pub fn from_bytes(bytes: &[u8]) -> Result<Self, RatchetError> {
         if bytes.len() != 32 + 4 + 4 + 96 {
             return Err(RatchetError::InvalidHeader);
         }

         let mut dh_bytes = [0u8; 32];
         dh_bytes.copy_from_slice(&bytes[0..32]);
         let dh_pub = PublicKey::from(dh_bytes);

         let mut pn_bytes = [0u8; 4];
         pn_bytes.copy_from_slice(&bytes[32..36]);
         let pn = u32::from_be_bytes(pn_bytes);

         let mut n_bytes = [0u8; 4];
         n_bytes.copy_from_slice(&bytes[36..40]);
         let n = u32::from_be_bytes(n_bytes);

         let mut signature = [0u8; 96];
         signature.copy_from_slice(&bytes[40..136]);

         Ok(RatchetHeader {
             dh_pub,
             pn,
             n,
             signature,
         })
     }
 }

 // ----------------------------------------------------------------------------
 // Core Structures
 // ----------------------------------------------------------------------------

 /// The Double Ratchet Session
 #[derive(Zeroize, ZeroizeOnDrop)]
 pub struct DoubleRatchet {
     // Diffie-Hellman Ratchet
     #[zeroize(skip)]
     dh_pair: KeyPair,
     #[zeroize(skip)]
     dh_remote: Option<DhPublicKey>,

     // Identity Keys for Signing
     self_identity_key: [u8; 32],
     #[zeroize(skip)]
     remote_identity_public_key: [u8; 32],

     // Root Chain
     rk: [u8; 32],

     // Symmetric-Key Ratchets
     ck_s: Option<[u8; 32]>,
     ck_r: Option<[u8; 32]>,

     // State
     #[zeroize(skip)]
     ns: u32,
     #[zeroize(skip)]
     nr: u32,
     #[zeroize(skip)]
     pn: u32,

     // Skipped Message Keys: (PublicKey, nr) -> (MessageKey, IV)
     #[zeroize(skip)]
     mkskipped: HashMap<([u8; 32], u32), ([u8; 32], [u8; 12])>,
 }

 impl DoubleRatchet {
     /// Initialize Alice's session
     pub fn new_alice(
         sk: [u8; 32],
         bob_dh_public_key: DhPublicKey,
         self_identity_key: [u8; 32],
         bob_identity_public_key: [u8; 32],
     ) -> Self {
         let mut rng = rand_core::OsRng;
         let dh_s = StaticSecret::random_from_rng(&mut rng);
         let dh_s_pub = PublicKey::from(&dh_s);

         let dh_out = dh_s.diffie_hellman(&bob_dh_public_key);
         let (rk, ck_s) = Self::kdf_rk(&sk, dh_out.as_bytes());

         DoubleRatchet {
             dh_pair: (dh_s, dh_s_pub),
             dh_remote: Some(bob_dh_public_key),
             self_identity_key,
             remote_identity_public_key: bob_identity_public_key,
             rk,
             ck_s: Some(ck_s),
             ck_r: None,
             ns: 0,
             nr: 0,
             pn: 0,
             mkskipped: HashMap::new(),
         }
     }

     /// Initialize Bob's session
     pub fn new_bob(
         sk: [u8; 32],
         bob_key_pair: KeyPair,
         self_identity_key: [u8; 32],
         alice_identity_public_key: [u8; 32],
     ) -> Self {
         DoubleRatchet {
             dh_pair: bob_key_pair,
             dh_remote: None,
             self_identity_key,
             remote_identity_public_key: alice_identity_public_key,
             rk: sk,
             ck_s: None,
             ck_r: None,
             ns: 0,
             nr: 0,
             pn: 0,
             mkskipped: HashMap::new(),
         }
     }

     /// Encrypt a message
     pub fn ratchet_encrypt(
         &mut self,
         plaintext: &[u8],
         associated_data: &[u8],
     ) -> (RatchetHeader, Vec<u8>) {
         let (ck_s, mk, iv) = Self::kdf_ck(&self.ck_s.expect("Sender chain key missing"));
         self.ck_s = Some(ck_s);

         let mut header = RatchetHeader {
             dh_pub: self.dh_pair.1,
             pn: self.pn,
             n: self.ns,
             signature: [0u8; 96], // Placeholder
         };
         self.ns += 1;

         // Sign the header
         let sign_bytes = header.to_bytes_for_signing();
         let mut output = VXEdDSAOutput {
             signature: [0u8; 96],
             vrf: [0u8; 32],
         };

         // This call is slightly unsafe due to FFI design, but we are inside Rust calling Rust FFI
         vxeddsa_sign(
             &self.self_identity_key,
             sign_bytes.as_ptr(),
             sign_bytes.len(),
             &mut output,
         );
         header.signature = output.signature;

         // Proper Associated Data framing
         let header_bytes = header.to_bytes();
         let mut ad = Vec::with_capacity(8 + associated_data.len() + header_bytes.len());
         ad.extend_from_slice(&(associated_data.len() as u64).to_be_bytes());
         ad.extend_from_slice(associated_data);
         ad.extend_from_slice(&header_bytes);

         let ciphertext = Self::encrypt(&mk, &iv, plaintext, &ad);

         (header, ciphertext)
     }

     /// Decrypt a message - ATOMIC UPDATE STRATEGY
     pub fn ratchet_decrypt(
         &mut self,
         header: &RatchetHeader,
         ciphertext: &[u8],
         associated_data: &[u8],
     ) -> Result<Vec<u8>, RatchetError> {
         // Prepare AD first
         let header_bytes = header.to_bytes();
         let mut ad = Vec::with_capacity(8 + associated_data.len() + header_bytes.len());
         ad.extend_from_slice(&(associated_data.len() as u64).to_be_bytes());
         ad.extend_from_slice(associated_data);
         ad.extend_from_slice(&header_bytes);

         // 1. Try skipped message keys first (Timing Protection)
         // These keys are already authenticated by the AEAD (if it decrypts successfully)
         if let Some((mk, iv)) = self
             .mkskipped
             .get(&(header.dh_pub.as_bytes().clone(), header.n))
         {
             let plaintext = Self::decrypt(mk, iv, ciphertext, &ad)?;
             // Only remove the key after successful decryption
             self.mkskipped
                 .remove(&(header.dh_pub.as_bytes().clone(), header.n));
             return Ok(plaintext);
         }

         // 2. Verify Signature
         // Only done if not a skipped key, to prevent denial of service or timing leaks on valid old messages
         let sign_bytes = header.to_bytes_for_signing();
         let mut v_out = [0u8; 32];
         let valid = vxeddsa_verify(
             &self.remote_identity_public_key,
             sign_bytes.as_ptr(),
             sign_bytes.len(),
             &header.signature,
             &mut v_out,
         );

         if !valid {
             return Err(RatchetError::InvalidSignature);
         }

         // 3. Determine necessary ratchet steps (WITHOUT modifying state yet)
         // We will simulate the state updates in local variables.

         // Clone current state variables needed for simulation
         let mut current_rk = self.rk;
         let mut current_ck_r = self.ck_r;
         let mut current_dh_remote = self.dh_remote;
         let mut current_nr = self.nr;
         let mut current_dh_pair = (self.dh_pair.0.clone(), self.dh_pair.1); // Clone DH pair as StaticSecret is opaque

         let mut skipped_keys = HashMap::new();

         // Check for DHRatchet step
         let new_dh = if let Some(remote) = current_dh_remote {
             remote != header.dh_pub
         } else {
             true
         };

         if new_dh {
             if let Some(ck_r) = current_ck_r {
                 Self::simulate_skip_message_keys(
                     ck_r,
                     current_nr,
                     header.pn,
                     &current_dh_remote.unwrap(),
                     &mut skipped_keys,
                 )?;
             }
             // DH Ratchet Simulation
             current_nr = 0;
             current_dh_remote = Some(header.dh_pub);

             // Step 1
             let dh_out_recv = current_dh_pair.0.diffie_hellman(&header.dh_pub);
             let (new_rk, new_ck_r) = Self::kdf_rk(&current_rk, dh_out_recv.as_bytes());
             current_rk = new_rk;
             current_ck_r = Some(new_ck_r);

             // Step 2
             let mut rng = rand_core::OsRng;
             // Note: We generate new pair but don't commit it yet.
             // Wait, we need the new pair for the next send, but not for this decrypt?
             // Correct. Ideally we generate it here but only update self later.
             let new_dh_s = StaticSecret::random_from_rng(&mut rng);
             let new_dh_s_pub = PublicKey::from(&new_dh_s);

             let dh_out_send = new_dh_s.diffie_hellman(&header.dh_pub);
             let (_new_rk_2, _new_ck_s) = Self::kdf_rk(&current_rk, dh_out_send.as_bytes());
             // current_rk = _new_rk_2; // Unused in simulation
             // new_ck_s is for SENDING, we don't update it for receiving path directly
             // but we need to update self.ck_s if we commit.

             // Update local tracking
             current_dh_pair = (new_dh_s, new_dh_s_pub);
             // We need to store the computed input_ck_s (from step 2) to commit later
         }

         // Forward skip in current chain
         if let Some(ck_r) = current_ck_r {
             let (end_ck, _new_nr) = Self::simulate_skip_message_keys(
                 ck_r,
                 current_nr,
                 header.n,
                 &current_dh_remote.unwrap(),
                 &mut skipped_keys,
             )?;
             current_ck_r = Some(end_ck);
             // current_nr = new_nr; // Unused in simulation
         }

         // 4. Derive MK for this message
         let (_new_ck_r, mk, iv) = Self::kdf_ck(&current_ck_r.unwrap());
         // current_ck_r = Some(new_ck_r); // Unused
         // current_nr += 1; // Unused

         // 5. Attempt Decryption
         let plaintext = Self::decrypt(&mk, &iv, ciphertext, &ad)?;

         // 6. COMMIT STATE (Success)
         // Only if we reached here, decryption matched authentication tag.

         // Apply skipped keys
         self.mkskipped.extend(skipped_keys);

         // Setup new DH if changed
         if new_dh {
             self.pn = self.ns;
             self.ns = 0;
             self.nr = 0;
             self.dh_remote = Some(header.dh_pub);

             // Re-run the DH KDFs to get the exact state we simulated
             // (Or we could have captured them. Re-running is safer for code clarity unless expensive)
             // It's cheap enough.

             let dh_out_recv = self.dh_pair.0.diffie_hellman(&header.dh_pub);
             let (new_rk, new_ck_r) = Self::kdf_rk(&self.rk, dh_out_recv.as_bytes());
             self.rk = new_rk;
             self.ck_r = Some(new_ck_r);

             // We used `current_dh_pair` (randomly generated) in simulation.
             // We MUST use the SAME one.
             // Accessing the private key from `current_dh_pair` is tricky due to opaque type?
             // No, StaticSecret is not Clone but we cloned it earlier?
             // Actually `x25519_dalek::StaticSecret` doesn't enforce Clone usually.
             // Let's rely on the fact that if we generated it, we must use THAT one.

             self.dh_pair = current_dh_pair; // Move it here

             // Re-calc send chain
             let dh_out_send = self.dh_pair.0.diffie_hellman(&header.dh_pub);
             let (new_rk_2, new_ck_s) = Self::kdf_rk(&self.rk, dh_out_send.as_bytes());
             self.rk = new_rk_2;
             self.ck_s = Some(new_ck_s);
         }

         // Advance Chain
         // If we just did a ratchet, `self.ck_r` is the root-derived one.
         // We need to advance it `header.n` times.
         if new_dh {
             // We already set ck_r to root-derived.
             // We need to skip to header.n
             // We can use the helper directly now that we are committing
             if header.n > 0 {
                 // We simulate-skipped earlier. We just need to advance the key
                 let (final_ck, val_nr) = Self::advance_chain(self.ck_r.unwrap(), 0, header.n);
                 self.ck_r = Some(final_ck);
                 self.nr = val_nr;
             }
         } else {
             // Just advance in current chain
             let (final_ck, val_nr) = Self::advance_chain(self.ck_r.unwrap(), self.nr, header.n);
             self.ck_r = Some(final_ck);
             self.nr = val_nr;
         }

         // Finally step for the message itself
         // The `kdf_ck` above produced the NEXT ck.
         // We need to match that.
         let (final_step_ck, _, _) = Self::kdf_ck(&self.ck_r.unwrap());
         self.ck_r = Some(final_step_ck);
         self.nr += 1;

         Ok(plaintext)
     }

     // Helper to simulate skipping without modifying state
     fn simulate_skip_message_keys(
         mut local_ck: [u8; 32],
         start_n: u32,
         until_n: u32,
         remote_dh: &DhPublicKey,
         skipped_map: &mut HashMap<([u8; 32], u32), ([u8; 32], [u8; 12])>,
     ) -> Result<([u8; 32], u32), RatchetError> {
         if start_n.saturating_add(MAX_SKIP) < until_n {
             return Err(RatchetError::OldMessageKeysLimitReached);
         }

         let mut curr_n = start_n;
         while curr_n < until_n {
             let (next_ck, mk, iv) = Self::kdf_ck(&local_ck);
             local_ck = next_ck;
             skipped_map.insert((remote_dh.as_bytes().clone(), curr_n), (mk, iv));
             curr_n += 1;
         }
         Ok((local_ck, curr_n))
     }

     // Helper to just advance chain (used in commit)
     fn advance_chain(mut ck: [u8; 32], start_n: u32, until_n: u32) -> ([u8; 32], u32) {
         let mut curr = start_n;
         while curr < until_n {
             let (next, _, _) = Self::kdf_ck(&ck);
             ck = next;
             curr += 1;
         }
         (ck, curr)
     }

     // ---------------- Helper Crypto Functions ----------------

     fn kdf_rk(rk: &[u8; 32], dh_out: &[u8; 32]) -> ([u8; 32], [u8; 32]) {
         let hk = Hkdf::<Sha512>::new(Some(rk), dh_out);
         let mut okm = [0u8; 64];
         hk.expand(HKDF_INFO_ROOT, &mut okm).expect("KDF Check");

         let mut new_rk = [0u8; 32];
         let mut new_ck = [0u8; 32];
         new_rk.copy_from_slice(&okm[0..32]);
         new_ck.copy_from_slice(&okm[32..64]);

         (new_rk, new_ck)
     }

     fn kdf_ck(ck: &[u8; 32]) -> ([u8; 32], [u8; 32], [u8; 12]) {
         type HmacSha256 = Hmac<Sha256>;

         // 1. Next Chain Key
         let mut mac = <HmacSha256 as Mac>::new_from_slice(ck).expect("HMAC");
         mac.update(&[0x01]);
         let next_ck_bytes = mac.finalize().into_bytes();

         // 2. Message Key
         let mut mac = <HmacSha256 as Mac>::new_from_slice(ck).expect("HMAC");
         mac.update(&[0x02]);
         let mk_bytes = mac.finalize().into_bytes();

         // 3. IV (12 bytes)
         let mut mac = <HmacSha256 as Mac>::new_from_slice(ck).expect("HMAC");
         mac.update(&[0x03]);
         let iv_bytes_full = mac.finalize().into_bytes();

         let mut next_ck = [0u8; 32];
         let mut mk = [0u8; 32];
         let mut iv = [0u8; 12];

         next_ck.copy_from_slice(&next_ck_bytes);
         mk.copy_from_slice(&mk_bytes);
         iv.copy_from_slice(&iv_bytes_full[0..12]);

         (next_ck, mk, iv)
     }

     fn encrypt(mk: &[u8; 32], iv: &[u8; 12], plaintext: &[u8], ad: &[u8]) -> Vec<u8> {
         let key = Key::<Aes256Gcm>::from_slice(mk);
         let cipher = Aes256Gcm::new(key);
         let nonce = Nonce::from_slice(iv);

         cipher
             .encrypt(
                 nonce,
                 Payload {
                     msg: plaintext,
                     aad: ad,
                 },
             )
             .expect("Encryption failure")
     }

     fn decrypt(
         mk: &[u8; 32],
         iv: &[u8; 12],
         ciphertext: &[u8],
         ad: &[u8],
     ) -> Result<Vec<u8>, RatchetError> {
         let key = Key::<Aes256Gcm>::from_slice(mk);
         let cipher = Aes256Gcm::new(key);
         let nonce = Nonce::from_slice(iv);

         cipher
             .decrypt(
                 nonce,
                 Payload {
                     msg: ciphertext,
                     aad: ad,
                 },
             )
             .map_err(|_| RatchetError::DecryptionFailed)
     }
 }

 // ----------------------------------------------------------------------------
 // Tests
 // ----------------------------------------------------------------------------
 #[cfg(test)]
 mod tests {
     use super::*;
     use crate::vxeddsa::gen_keypair;

     #[test]
     fn test_ratchet_basic_flow_signed() {
         let sk = [0x55u8; 32];

         let mut rng = rand_core::OsRng;
         let bob_dh_private = StaticSecret::random_from_rng(&mut rng);
         let bob_dh_public = PublicKey::from(&bob_dh_private);

         let alice_id = gen_keypair();
         let bob_id = gen_keypair();

         let mut alice = DoubleRatchet::new_alice(sk, bob_dh_public, alice_id.secret, bob_id.public);
         let mut bob = DoubleRatchet::new_bob(
             sk,
             (bob_dh_private, bob_dh_public),
             bob_id.secret,
             alice_id.public,
         );

         let msg1 = b"Hello Bob!";
         let ad1 = b"Metadata";
         let (head1, cipher1) = alice.ratchet_encrypt(msg1, ad1);

         let decrypted1 = bob
             .ratchet_decrypt(&head1, &cipher1, ad1)
             .expect("Bob decrypts msg1");
         assert_eq!(decrypted1, msg1);

         let msg2 = b"Hello Alice!";
         let (head2, cipher2) = bob.ratchet_encrypt(msg2, &[]);

         let decrypted2 = alice
             .ratchet_decrypt(&head2, &cipher2, &[])
             .expect("Alice decrypts msg2");
         assert_eq!(decrypted2, msg2);
     }

     #[test]
     fn test_invalid_signature() {
         let sk = [0x77u8; 32];
         let mut rng = rand_core::OsRng;
         let bob_dh_private = StaticSecret::random_from_rng(&mut rng);
         let bob_dh_public = PublicKey::from(&bob_dh_private);

         let alice_id = gen_keypair();
         let bob_id = gen_keypair();

         let mut alice = DoubleRatchet::new_alice(sk, bob_dh_public, alice_id.secret, bob_id.public);
         let mut bob = DoubleRatchet::new_bob(
             sk,
             (bob_dh_private, bob_dh_public),
             bob_id.secret,
             alice_id.public,
         );

         let msg = b"Tampered";
         let (mut head, cipher) = alice.ratchet_encrypt(msg, &[]);

         // Tamper signature
         head.signature[0] ^= 0xFF; // Flip bits

         let err = bob.ratchet_decrypt(&head, &cipher, &[]);
         assert_eq!(err, Err(RatchetError::InvalidSignature));
     }
 }